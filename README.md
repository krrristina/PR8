# Практическая работа № 8
## Тема: "Работа с MongoDB: подключение, создание коллекции, CRUD-операции"
## Подготовила: Сорокина К.С., ЭФМО-01-25.
### Выполнены следующие цели:
- Понять базовые принципы документной БД MongoDB (документ, коллекция, BSON, _id:ObjectID).
- Научиться подключаться к MongoDB из Go с использованием официального драйвера.
- Создать коллекцию, индексы и реализовать CRUD для одной сущности (например, notes).
- Отработать фильтрацию, пагинацию, обновления (в т.ч. частичные), удаление и обработку ошибок.

### Версии MongoDB и Mongosh:
Using MongoDB:          8.2.2

Using Mongosh:          2.5.10

#### Команда для запуска:
```bash
go run ./cmd/api
```
### Примеры запросов через Postman:
#### Создание заметки:
![создание](https://github.com/krrristina/PR8/blob/main/screenshots/POST%20%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%BC%D0%B5%D1%82%D0%BA%D0%B8.png)

#### GET список заметок:
![список](https://github.com/krrristina/PR8/blob/main/screenshots/%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA%20%D0%B7%D0%B0%D0%BC%D0%B5%D1%82%D0%BE%D0%BA%20get.png)

#### Обновление заметки:
![patch](https://github.com/krrristina/PR8/blob/main/screenshots/%D0%BE%D0%B1%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%BC%D0%B5%D1%82%D0%BA%D0%B8%20PATCH.png)

#### Получение по id:
![id](https://github.com/krrristina/PR8/blob/main/screenshots/%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BF%D0%BE%20id%20get.png)

#### Проверка работоспособности:
![health](https://github.com/krrristina/PR8/blob/main/screenshots/health.png)

#### Удаление заметки:
![delete](https://github.com/krrristina/PR8/blob/main/screenshots/delete.png)

## Типовые проблемы и их решения

| Проблема / Ошибка | Возможная причина | Решение |
| :--- | :--- | :--- |
| **`connection refused`** или **`i/o timeout`** | Контейнер с MongoDB не запущен, либо порт 27017 занят/не проброшен. | 1. Проверить статус: `docker compose ps`<br>2. Запустить: `docker compose up -d` |
| **`auth error: sasl conversation error`** | Неверный логин/пароль в `.env`, либо попытка подключиться с паролем к локальной БД без пароля. | 1. Для Docker: проверить `MONGO_INITDB_ROOT_...` в docker-compose.yml и `.env`.<br>2. Для локальной: убрать `root:secret@` из `MONGO_URI`. |
| **`duplicate key error` (E11000)** | Попытка создать заметку с названием (`title`), которое уже существует в базе. | В коллекции стоит уникальный индекс на поле `title`. Используйте другое название или удалите старую заметку. |
| **`invalid ObjectID hex string`** | В URL передан ID, который не является валидной 24-символьной Hex-строкой (например, просто "123"). | Использовать только настоящие ID, полученные при создании (вида `651f...`). В коде проверять ошибку `primitive.ObjectIDFromHex`. |
| **`virtualization support not detected`** | В BIOS отключена виртуализация (VT-x/SVM) или конфликт с Hyper-V в Windows. | 1. Включить Virtualization в BIOS.<br>2. В PowerShell: `bcdedit /set hypervisorlaunchtype auto`.<br>3. `wsl --update`. |
| **Пустой ответ или ошибка парсинга JSON** | В теле запроса отправлен некорректный JSON или забыли заголовок Content-Type. | В Postman выбрать `Body -> raw -> JSON`. Убедиться, что поля называются `title` и `content`. |

---

## Ответы на контрольные вопросы

### 1. Чем документная модель MongoDB принципиально отличается от реляционной? Когда она удобнее?
**Отличие:**
*   **Реляционная (SQL):** Данные хранятся в таблицах со строгой схемой (Schema). Связи реализуются через внешние ключи (JOIN). Для изменения структуры нужно делать миграции (ALTER TABLE).
*   **Документная (MongoDB):** Данные хранятся в коллекциях в виде BSON-документов (аналог JSON). Схема динамическая — в одной коллекции могут лежать документы с разным набором полей. Поддерживает вложенные объекты и массивы.

**Когда удобнее:**
*   Когда структура данных часто меняется или не определена заранее (гибкость).
*   Для хранения иерархических данных (каталоги, профили пользователей с настройками).
*   Для быстрой разработки (Rapid Prototyping).
*   Когда нужна высокая скорость записи и горизонтальное масштабирование (Sharding).

### 2. Что такое ObjectID и зачем нужен `_id`? Как корректно парсить/валидировать его в Go?
**Что это:**
`_id` — это обязательное поле первичного ключа в MongoDB. Если его не передать, база создаст его сама. Тип данных — `ObjectID` (12 байт):
*   4 байта: метка времени (timestamp).
*   5 байт: случайное значение (уникальность машины/процесса).
*   3 байта: счетчик (инкремент).

**Зачем нужен:** Гарантирует глобальную уникальность документа даже в распределенных системах (без центрального счетчика, как `AUTO_INCREMENT` в SQL).

**Работа в Go:**
Используется пакет `go.mongodb.org/mongo-driver/bson/primitive`.
*   **Валидация/Парсинг:**
    ```go
    oid, err := primitive.ObjectIDFromHex(idString)
    if err != nil {
        // ID невалиден (не hex или неверная длина)
        return error
    }
    ```

### 3. Какие операции CRUD предоставляет драйвер MongoDB и какие операторы обновления вы знаете?
**Операции драйвера (основные):**
*   **C:** `InsertOne`, `InsertMany`
*   **R:** `Find` (возвращает курсор), `FindOne` (декодирует сразу в структуру)
*   **U:** `UpdateOne`, `UpdateMany`, `ReplaceOne`
*   **D:** `DeleteOne`, `DeleteMany`

**Операторы обновления (используются внутри `$set`, `$inc` и т.д.):**
*   `$set`: установить значение поля (самый частый).
*   `$unset`: удалить поле из документа.
*   `$inc`: увеличить числовое значение (счетчик).
*   `$push`: добавить элемент в массив.
*   `$pull`: удалить элемент из массива.
*   `$currentDate`: установить текущую дату.

### 4. Как устроены индексы в MongoDB? Как создать уникальный индекс и чем он грозит при вставке?
**Устройство:**
Индексы в MongoDB обычно представляют собой структуру **B-Tree**. Они хранят отсортированные значения определенного поля, что позволяет искать данные за логарифмическое время `O(log N)` вместо полного перебора коллекции `O(N)`.

**Создание уникального индекса (в Go):**
```go
mod := mongo.IndexModel{
    Keys:    bson.D{{Key: "title", Value: 1}}, // 1 - по возрастанию
    Options: options.Index().SetUnique(true),
}
collection.Indexes().CreateOne(ctx, mod)
```

**Чем грозит:**
Если попытаться вставить документ с таким же значением индексируемого поля (`title`), база данных **отклонит операцию записи** и вернет ошибку `E11000 duplicate key error`. Приложение должно перехватывать эту ошибку (обычно возвращая клиенту HTTP 409 Conflict).

### 5. Почему важно использовать context.WithTimeout при вызовах к базе? Что произойдет при его срабатывании?
**Почему важно:**
Взаимодействие с БД — это сетевая операция. Сеть может "повиснуть", база может уйти в долгую блокировку. Без таймаута горутина (goroutine) в Go может зависнуть навсегда, ожидая ответа. Это приведет к утечке ресурсов (памяти, сокетов) и падению всего сервиса.

**Что произойдет:**
1.  Если время, отведенное в `context.WithTimeout`, истекло, контекст переходит в состояние `Done`.
2.  Драйвер MongoDB внутри метода (например, `Find`) проверяет этот контекст.
3.  Обнаружив отмену, драйвер немедленно **прерывает сетевое соединение** и прекращает ожидание.
4.  Функция возвращает ошибку `context.DeadlineExceeded`.
